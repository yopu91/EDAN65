package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short MUL = 2;
		static public final short ADD = 3;
		static public final short SUB = 4;
		static public final short DIV = 5;
		static public final short MOD = 6;
		static public final short EQ = 7;
		static public final short NEQ = 8;
		static public final short GTHN = 9;
		static public final short LTHN = 10;
		static public final short GEQ = 11;
		static public final short LEQ = 12;
		static public final short NUMERAL = 13;
		static public final short INT = 14;
		static public final short RPAR = 15;
		static public final short IF = 16;
		static public final short WHILE = 17;
		static public final short RETURN = 18;
		static public final short LPAR = 19;
		static public final short LBRACKET = 20;
		static public final short RBRACKET = 21;
		static public final short COMMA = 22;
		static public final short SEMI = 23;
		static public final short ELSE = 24;
		static public final short ASSIGN = 25;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"MUL",
			"ADD",
			"SUB",
			"DIV",
			"MOD",
			"EQ",
			"NEQ",
			"GTHN",
			"LTHN",
			"GEQ",
			"LEQ",
			"NUMERAL",
			"INT",
			"RPAR",
			"IF",
			"WHILE",
			"RETURN",
			"LPAR",
			"LBRACKET",
			"RBRACKET",
			"COMMA",
			"SEMI",
			"ELSE",
			"ASSIGN"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjbSbpL5KKnh$N48cHZf5E8tH8GWWXq0tfbam6PqN54KVKTa81ALrPxYmth2XNx5nGHVa" +
		"7K9HLLhbqfLM24pA8Yk208Y06Y2JCuF7tRb$Cwwxk9xgoABlhTxvxxdVUVQzlxZkH4YazgA" +
		"bwG4lra1xM8tfKZ#bnBTCJUb9FuSsAyVfZlEjZl4Knteqntiqntgqntkqntk8OxwuORqcCT" +
		"s#CTt#CzqnDRr13ka4twHRTfZjqf#xMFRfF4pHHrzRmSYgeiuQNLAEkLfEkqHIbL4TjNWCr" +
		"QgUNrMPrXIRfsHgrb$DiJY#nsyljk9xNAYNi8pFLwqLs9AVdolOefmRsjAYqhb9RnUvrLUJ" +
		"Jj5nNAgDknisQgQVTYfF92pxFHhpnKLOpo8e#woLliMF4#LgW7ZIhwzH7BA9XpBflqOyknW" +
		"utKrIhPZjjznLpD9SuJmk9BsW5SINFsC8zM$b5xTopWxxGoLLTr7R$x$r7l8Jh27Nk7QtdN" +
		"3Lm0YTp0XPovgfx6RwrlBcSWF1qbyvK8vK5kisbr0RKfchMNiwp6RVRuJkUvpl8Vq7nTavr" +
		"ErA#HndUtKOwSOhtj7BtAlDcjsAQ6FZU4QwOTd#JKXv4lF5HG7y9xr7A2kJzh1Dmpm6d0Uj" +
		"C9oRTUaat4shIQocct4oIfsXsclOLQUuUy5VEk5$NwAAqUetSvxWKR0Z7fJn8Gnsy2U$2M$" +
		"0#l7UnfXRKh8Ut6Mn3Dy87i0a#zFuHs0mZFZyCrEfxz2XiXR6IbvZ4#4HaxPsm2tQNtpFH4" +
		"AdPHnZsu$qm3Gv19$mAFJ0CGt0C5iFli1J2VIZ2AAo2a$0gd88tu0oi$RizYDcRiv2eUFQa" +
		"rmGqLRbc1M7JUAuBVluLUDcFNoTilvHdCBC3aRKE#klVYTnlRKNzMCHR5ncFL7bMpefsLCo" +
		"DHkwNY8oRlBPvdUzraTSbNfTvNUdrDQzhlAxp#jVv$JVmsLZbzqJFtkcA#jKbiNtsXye#Ti" +
		"5#jdDsrixOQJjb9yky8tR2ZuwMpG#x#9jjzlbv#yKubJPY1rpEoRKVuGVWJR7lO2$iWMzXD" +
		"tm3NyDNjik#j9ssmxRRDll2jjhdzfbzQf$OnxR5hNROzjj1TCnbetR8Vc8mH0SCw8a1NR6U" +
		"VZQHtXPKPHv#dgwQfw$ckJBiLWNo0kD#hkj7i$JQ77uFB62kbvfUQWRG0RGFxKC7qK6qbRe" +
		"sQ8UPq06pe1DcGnVCWMveuPf$oWpNym8D$Gb3mwB6");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = func_list.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
				}
			},
			Action.RETURN,	// [1] function = paramFunc
			new Action() {	// [2] paramFunc = INT idUse.id LPAR param_list.p RPAR LBRACKET stmt_list.t RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_t = _symbols[offset + 7];
					final List t = (List) _symbol_t.value;
					 return new ParamFunc(id,p,t);
				}
			},
			new Action() {	// [3] funcStmt = idUse.id LPAR arg_list.l RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					return new FuncStmt(id,l);
				}
			},
			Action.RETURN,	// [4] stmt = ifStmt
			Action.RETURN,	// [5] stmt = whileStmt
			Action.RETURN,	// [6] stmt = declare
			Action.RETURN,	// [7] stmt = funcStmt
			Action.RETURN,	// [8] stmt = assign
			Action.RETURN,	// [9] stmt = returnStmt
			new Action() {	// [10] ifStmt = IF LPAR expr.a RPAR LBRACKET stmt.t RBRACKET else_exp.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol _symbol_e = _symbols[offset + 8];
					final Opt e = (Opt) _symbol_e.value;
					return new IfStmt(a,t,e);
				}
			},
			new Action() {	// [11] param = INT idUse.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdUse id = (IdUse) _symbol_id.value;
					return new Param(id);
				}
			},
			new Action() {	// [12] param = COMMA INT idUse.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 3];
					final IdUse id = (IdUse) _symbol_id.value;
					 return new Param(id);
				}
			},
			Action.NONE,  	// [13] param = 
			new Action() {	// [14] arg = idUse.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					return new Argument(id);
				}
			},
			new Action() {	// [15] arg = COMMA idUse.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdUse id = (IdUse) _symbol_id.value;
					 return new Argument(id);
				}
			},
			Action.NONE,  	// [16] arg = 
			new Action() {	// [17] else_exp = ELSE LBRACKET stmt.u RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_u = _symbols[offset + 3];
					final Stmt u = (Stmt) _symbol_u.value;
					return new Opt(u);
				}
			},
			new Action() {	// [18] else_exp = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			new Action() {	// [19] whileStmt = WHILE LPAR expr.a RPAR LBRACKET stmt.t RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final Stmt t = (Stmt) _symbol_t.value;
					return new WhileStmt(a,t);
				}
			},
			new Action() {	// [20] declare = INT idUse.id SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdUse id = (IdUse) _symbol_id.value;
					 return new Declare(id);
				}
			},
			new Action() {	// [21] returnStmt = RETURN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new ReturnStmt(a);
				}
			},
			new Action() {	// [22] assign = idUse.id ASSIGN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					return new Assignment(id,a);
				}
			},
			new Action() {	// [23] param_list = param.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Param a = (Param) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [24] param_list = param_list.a param.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Param b = (Param) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [25] arg_list = arg.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Argument a = (Argument) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [26] arg_list = arg_list.a arg.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Argument b = (Argument) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [27] stmt_list = stmt.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Stmt a = (Stmt) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [28] stmt_list = stmt_list.a stmt.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [29] func_list = function.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Function a = (Function) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [30] func_list = func_list.a function.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Function b = (Function) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [31] mul = expr.a MUL expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a,b);
				}
			},
			new Action() {	// [32] add = expr.a ADD expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Add(a,b);
				}
			},
			new Action() {	// [33] sub = expr.a SUB expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a,b);
				}
			},
			new Action() {	// [34] div = expr.a DIV expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a,b);
				}
			},
			new Action() {	// [35] mod = expr.a MOD expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a,b);
				}
			},
			new Action() {	// [36] eq_expr = expr.a EQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Eq(a,b);
				}
			},
			new Action() {	// [37] neq_expr = expr.a NEQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Neq(a,b);
				}
			},
			new Action() {	// [38] gthn_expr = expr.a GTHN expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Gthn(a,b);
				}
			},
			new Action() {	// [39] lthn_expr = expr.a LTHN expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Lthn(a,b);
				}
			},
			new Action() {	// [40] geq_expr = expr.a GEQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Geq(a,b);
				}
			},
			new Action() {	// [41] leq_expr = expr.a LEQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					return new Leq(a,b);
				}
			},
			Action.RETURN,	// [42] expr = numeral
			Action.RETURN,	// [43] expr = idUse
			Action.RETURN,	// [44] expr = mul
			Action.RETURN,	// [45] expr = add
			Action.RETURN,	// [46] expr = sub
			Action.RETURN,	// [47] expr = div
			Action.RETURN,	// [48] expr = mod
			Action.RETURN,	// [49] expr = eq_expr
			Action.RETURN,	// [50] expr = neq_expr
			Action.RETURN,	// [51] expr = gthn_expr
			Action.RETURN,	// [52] expr = lthn_expr
			Action.RETURN,	// [53] expr = geq_expr
			Action.RETURN,	// [54] expr = leq_expr
			new Action() {	// [55] numeral = NUMERAL.num
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol num = _symbols[offset + 1];
					return new Numeral(num);
				}
			},
			new Action() {	// [56] idUse = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					return new IdUse(id);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
