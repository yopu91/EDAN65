package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short NUMERAL = 2;
		static public final short INT = 3;
		static public final short IF = 4;
		static public final short WHILE = 5;
		static public final short RETURN = 6;
		static public final short SEMI = 7;
		static public final short ADD = 8;
		static public final short SUB = 9;
		static public final short LPAR = 10;
		static public final short RPAR = 11;
		static public final short LBRACKET = 12;
		static public final short RBRACKET = 13;
		static public final short MUL = 14;
		static public final short DIV = 15;
		static public final short MOD = 16;
		static public final short ASSIGN = 17;
		static public final short COMMA = 18;
		static public final short ELSE = 19;
		static public final short EQ = 20;
		static public final short NEQ = 21;
		static public final short GTHN = 22;
		static public final short LTHN = 23;
		static public final short GEQ = 24;
		static public final short LEQ = 25;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"NUMERAL",
			"INT",
			"IF",
			"WHILE",
			"RETURN",
			"SEMI",
			"ADD",
			"SUB",
			"LPAR",
			"RPAR",
			"LBRACKET",
			"RBRACKET",
			"MUL",
			"DIV",
			"MOD",
			"ASSIGN",
			"COMMA",
			"ELSE",
			"EQ",
			"NEQ",
			"GTHN",
			"LTHN",
			"GEQ",
			"LEQ"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9ojLLrmJLSK$axkvKRS8595Y4WYSQzmaqWG6ff8HFobQ6bQF$MJpdIyc$5alFFaoPjtuyK" +
		"3CnxQlfXX34hLJxG8hNzIfLKqh7vxdvLpzqtE3G$spBVNTzPQU#srrzbd7S3hn7fyYaBCn2" +
		"mim2QCmcYCGG768e8eHggr6erOd65jnY9C7D8wPKXh1UfedOsbgCKIvQtaASn76xwosNoX4" +
		"OPX3jOXtudWwpTQhy5w4pyPefzXBQv#S0u#DpaOt#5emCVasVpAQ3CvRC5uL0tXrwb#UIZ7" +
		"1XixXkdu25FnDVc8WCT5i1aJUE9c53aUum9Ued5h6BVIgTidc8HsBCTAT60rrdBDP6TziSD" +
		"B7Juju7waXOpaivQ0BGlOYe2j2jXd0LiJiC$9jlFspCKslhSSEODS933FLjHKmSXteRwVIH" +
		"$vbsXYZRzXjAsiooIUBSQO8vXvATz1ESzHOMzmGgt#6tQj7d8#YBMOzxeaWrUoXdusLQgFy" +
		"Eru6H6ovUphJVnOYBx0MWRhmtCmladcOFXGVYQ72B$iz$6Bgv$7cslwmJ1#4Hvr$JmVu5SK" +
		"vxD7dlR8SppISVCpzgZcpHl7hsiyx$j4hYbqriT3OxdwTAGFmypj6SaEuV7kpcONIl9SfgA" +
		"c2aQ#2ta1Yv4NS8xOQ4bMg6iFxEWWJXgkpsk98yH1uXXnY7X87E$toGQEKqGHSO3uddXA$4" +
		"Xqg$qkyO8uhS#zXCdbCF6Cw2FE#pOlvUJO829zohyZeiJEpBszfPpsKfOHouXwrLSJ3II5b" +
		"0iS$vKERtJEKARo0lMBrDwaSh7ALfLjAji7vD9Ch21fqUTLdDOxzZKgrxdhT5yULNgSvs$L" +
		"DzgleztKiNxWsZ1mx73M$KFHH1nrxAQMJYsmo#6i6Jfr$pn7lzlX2PK$XEnTvl0kXvzG#I1" +
		"BphrPzCzLlbJvHdFBKHbJ6GzPky$X#pDjNfNAr80rNRwGM$BMogVG8M$aTtajh#Ib$2ilR5" +
		"s38G$bRsMFClGFx7pVplU8QyHb#Lako7bvh3vFv4$EtSGb#OdpVtAEyozoKQxA5Rb8taFS9" +
		"6uGrudVY5#bLyvgX3jslYj$SFwBU2xFv3PLTUmW7ZkAnvwIomuJPOynVTmBHIbzPj2U8a#n" +
		"QvYliOgyniByIy1U6INubjbNogahPm#ie9n6VO9#2QwljRqhXzqw4ehA09v52NaQ7hjW6bE" +
		"88jkzFDJz3n4MEva=");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = func_list.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
				}
			},
			Action.RETURN,	// [1] function = paramFunc
			new Action() {	// [2] paramFunc = INT iddecl.id LPAR param_list.p RPAR LBRACKET stmt_list.t RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_t = _symbols[offset + 7];
					final List t = (List) _symbol_t.value;
					 return new ParamFunc(id,p,t);
				}
			},
			new Action() {	// [3] funccall = idUse.id LPAR arg_list.l RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					return new FuncCall(id,l);
				}
			},
			new Action() {	// [4] funcStmt = funccall.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final FuncCall a = (FuncCall) _symbol_a.value;
					return new FuncStmt(a);
				}
			},
			Action.RETURN,	// [5] stmt = ifStmt
			Action.RETURN,	// [6] stmt = whileStmt
			Action.RETURN,	// [7] stmt = declare
			Action.RETURN,	// [8] stmt = assign
			Action.RETURN,	// [9] stmt = returnStmt
			Action.RETURN,	// [10] stmt = funcStmt
			new Action() {	// [11] ifStmt = IF LPAR expr.a RPAR LBRACKET stmt_list.t RBRACKET else
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final List t = (List) _symbol_t.value;
					return new IfStmt(a,t);
				}
			},
			new Action() {	// [12] param = INT iddecl.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					return new Param(id);
				}
			},
			new Action() {	// [13] param_list = param.par
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_par = _symbols[offset + 1];
					final Param par = (Param) _symbol_par.value;
					 return new List().add(par);
				}
			},
			new Action() {	// [14] param_list = param_list.a COMMA param.par
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_par = _symbols[offset + 3];
					final Param par = (Param) _symbol_par.value;
					 return a.add(par);
				}
			},
			new Action() {	// [15] param_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			Action.RETURN,	// [16] arg = expr
			new Action() {	// [17] arg_list = arg.ar
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ar = _symbols[offset + 1];
					final Expr ar = (Expr) _symbol_ar.value;
					 return new List().add(ar);
				}
			},
			new Action() {	// [18] arg_list = arg_list.a COMMA arg.ar
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_ar = _symbols[offset + 3];
					final Expr ar = (Expr) _symbol_ar.value;
					 return a.add(ar);
				}
			},
			new Action() {	// [19] arg_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			new Action() {	// [20] else = ELSE LBRACKET stmt_list.u RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_u = _symbols[offset + 3];
					final List u = (List) _symbol_u.value;
					return new ElseStmt(u);
				}
			},
			Action.NONE,  	// [21] else = 
			new Action() {	// [22] whileStmt = WHILE LPAR expr.a RPAR LBRACKET stmt_list.t RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final List t = (List) _symbol_t.value;
					return new WhileStmt(a,t);
				}
			},
			new Action() {	// [23] declare = INT iddecl.id SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					 return new Declare(id, new Opt());
				}
			},
			new Action() {	// [24] declare = INT iddecl.id ASSIGN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final Expr a = (Expr) _symbol_a.value;
					 return new Declare(id,new Opt(a));
				}
			},
			new Action() {	// [25] returnStmt = RETURN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new ReturnStmt(a);
				}
			},
			new Action() {	// [26] assign = idUse.id ASSIGN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					return new Assignment(id,a);
				}
			},
			new Action() {	// [27] stmt_list = stmt.st
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_st = _symbols[offset + 1];
					final Stmt st = (Stmt) _symbol_st.value;
					 return new List().add(st);
				}
			},
			new Action() {	// [28] stmt_list = stmt_list.a stmt.st
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_st = _symbols[offset + 2];
					final Stmt st = (Stmt) _symbol_st.value;
					 return a.add(st);
				}
			},
			new Action() {	// [29] func_list = function.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 1];
					final Function func = (Function) _symbol_func.value;
					 return new List().add(func);
				}
			},
			new Action() {	// [30] func_list = func_list.a function.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_func = _symbols[offset + 2];
					final Function func = (Function) _symbol_func.value;
					 return a.add(func);
				}
			},
			new Action() {	// [31] compare = factor.a EQ factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Eq(a,b);
				}
			},
			new Action() {	// [32] compare = factor.a NEQ factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Neq(a,b);
				}
			},
			new Action() {	// [33] compare = factor.a GTHN factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Gthn(a,b);
				}
			},
			new Action() {	// [34] compare = factor.a LTHN factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Lthn(a,b);
				}
			},
			new Action() {	// [35] compare = factor.a GEQ factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Geq(a,b);
				}
			},
			new Action() {	// [36] compare = factor.a LEQ factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					return new Leq(a,b);
				}
			},
			new Action() {	// [37] expr = expr.a ADD term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Add(a, b);
				}
			},
			new Action() {	// [38] expr = expr.a SUB term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a, b);
				}
			},
			Action.RETURN,	// [39] expr = term
			Action.RETURN,	// [40] expr = compare
			new Action() {	// [41] term = term.a MUL factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a, b);
				}
			},
			new Action() {	// [42] term = term.a DIV factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a, b);
				}
			},
			new Action() {	// [43] term = term.a MOD factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a, b);
				}
			},
			Action.RETURN,	// [44] term = factor
			Action.RETURN,	// [45] factor = numeral
			Action.RETURN,	// [46] factor = funcStmt
			Action.RETURN,	// [47] factor = idUse
			new Action() {	// [48] numeral = NUMERAL.num
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol num = _symbols[offset + 1];
					return new Numeral(num);
				}
			},
			new Action() {	// [49] idUse = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					return new IdUse(id);
				}
			},
			new Action() {	// [50] iddecl = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					return new IdDecl(id);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
