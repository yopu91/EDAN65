Program ::= Function*;

abstract Function;
ParamFunc:Function 	::= IdUse Param* Stmt*;
Param			::= [IdUse];

abstract Stmt;

WhileStmt:Stmt		::= Cond:Expr Stmt*;
IfStmt:Stmt		::= Cond:Expr Then:Stmt*;
ElseStmt:Stmt		::= Stmt*; 
ReturnStmt:Stmt		::= Expr*;
FuncStmt:Stmt		::= IdUse Argument*;

abstract Argument;
IdArg:Argument 		::= [IdUse];
FuncArg:Argument	::= [FuncStmt];
ExprArg:Argument	::= [Expr];

Assignment:Stmt		::= IdUse Expr*;
Declare:Stmt		::= IdUse;


abstract Expr;
Numeral:Expr		::= <NUMERAL>;
IdUse:Expr		::= <ID>;
BinaryExpr:Expr		::= Expr;
Term:Expr		::= [Expr] Factor;
Factor:Expr		::= Expr;

Add:BinaryExpr		::= Left:Expr Right:Term;
Sub:BinaryExpr		::= Left:Expr Right:Term;
Div:BinaryExpr		::= Left:Term Right:Factor;
Mul:BinaryExpr		::= Left:Term Right:Factor;
Mod:BinaryExpr		::= Left:Term Right:Factor;

Neq:BinaryExpr                ::= Left:Expr Right:Expr;
Eq:BinaryExpr                ::= Left:Expr Right:Expr;
Leq:BinaryExpr                ::= Left:Expr Right:Expr;
Lthn:BinaryExpr                ::= Left:Expr Right:Expr;
Geq:BinaryExpr                ::= Left:Expr Right:Expr;
Gthn:BinaryExpr                ::= Left:Expr Right:Expr;

