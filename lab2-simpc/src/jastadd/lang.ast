Program ::= Function*;

abstract Function;
ParamFunc:Function 	::= IdUse Param* Stmt*;
Param			::= [IdUse];

abstract Stmt;

WhileStmt:Stmt		::= Cond:Expr Stmt*;
IfStmt:Stmt		::= Cond:Expr Then:Stmt*;
ElseStmt:Stmt		::= Stmt*; 
ReturnStmt:Stmt		::= Expr*;
FuncStmt:Stmt		::= IdUse Argument*;

abstract Argument;
IdArg:Argument 		::= [IdUse];
FuncArg:Argument	::= [FuncStmt];
ExprArg:Argument	::= [Expr];

Assignment:Stmt		::= IdUse Expr*;
Declare:Stmt		::= IdUse;


abstract Expr;
Numeral:Expr		::= <NUMERAL>;
IdUse:Expr		::= <ID>;
BinaryExpr:Expr		::= Expr;

DivMult:BinaryExpr	::= Expr;
PlusMinus:BinaryExpr 	::= Expr;
Compare:BinaryExpr	::= Expr;

Term:Expr 		::= Expr;

Add:Expr		::= Left:DivMult Right:PlusMinus;
Sub:Expr		::= Left:DivMult Right:PlusMinus;
Div:Expr		::= Left:Term Right:DivMult;
Mul:Expr		::= Left:Term Right:DivMult;
Mod:Expr		::= Left:Term Right:DivMult;

Neq:Expr	        ::= Left:Term Right:Term;
Eq:Expr		        ::= Left:Term Right:Term;
Leq:Expr	        ::= Left:Term Right:Term;
Lthn:Expr	        ::= Left:Term Right:Term;
Geq:Expr	        ::= Left:Term Right:Term;
Gthn:Expr	        ::= Left:Term Right:Term;

