%class "LangParser";
%package "lang.ast";

%embed {:
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}
:};


%terminals ID, NUMERAL, ASSIGN, IF,ELSE, WHILE, INT, RETURN, COMMA;
//Structure terminals
%terminals LPAR, RPAR, LBRACKET, RBRACKET, SEMI;

//Arith terminals
%terminals ADD, SUB, MUL, DIV, MOD;

//Comparsion terminals
%terminals EQ, NEQ, LEQ, LTHN, GEQ, GTHN, SEMI;

%typeof program = "Program";
%typeof function = "Function";
%typeof paramFunc = "ParamFunc";
%typeof funcStmt = "FuncStmt";
%typeof func_list = "List";
%typeof stmt = "Stmt";
%typeof stmt_list = "List";
%typeof ifStmt = "IfStmt";
%typeof else_exp = "Opt";
%typeof whileStmt = "WhileStmt";
%typeof returnStmt = "ReturnStmt";
%typeof assign = "Assignment";
%typeof declare = "Declare";
%typeof expr ="Expr";
%typeof numeral = "Numeral";
%typeof idUse = "IdUse";
%typeof param = "Param";
%typeof param_list = "List";
%typeof arg = "Argument";
%typeof arg_list = "List";
%typeof mul = "Mul";
%typeof div = "Div";
%typeof sub = "Sub";
%typeof mod = "Mod";
%typeof add = "Add";
%typeof eq_expr = "Eq";
%typeof neq_expr = "Neq";
%typeof gthn_expr = "Gthn";
%typeof lthn_expr = "Lthn";
%typeof geq_expr = "Geq";
%typeof leq_expr = "Leq";


%goal program;

program = func_list.a {: return new Program(a); :};

function = paramFunc;

paramFunc = INT idUse.id LPAR param_list.p RPAR LBRACKET stmt_list.t RBRACKET  {: return new ParamFunc(id,p,t); :};

funcStmt = idUse.id LPAR arg_list.l RPAR {:return new FuncStmt(id,l);:};

stmt = ifStmt | whileStmt| declare | funcStmt | assign | returnStmt;

ifStmt = IF LPAR expr.a RPAR LBRACKET stmt.t RBRACKET else_exp.e {:return new IfStmt(a,t,e);:};



/****************************/
param = INT idUse.id {:return new Param(id);:}
        | COMMA INT idUse.id {: return new Param(id);:}
        ;
/********************************/


arg = 
	idUse.id {:return new Argument(id);:}
	| COMMA idUse.id {: return new Argument(id);:}
	;

else_exp =
	ELSE LBRACKET stmt.u RBRACKET {:return new Opt(u);:}
	| /*epsilon*/ {: return new Opt();:}
	;

whileStmt = WHILE LPAR expr.a RPAR LBRACKET stmt.t RBRACKET {:return new WhileStmt(a,t);:};

declare = INT idUse.id SEMI{: return new Declare(id);:};

returnStmt = RETURN expr.a SEMI {: return new ReturnStmt(a);:};

assign = idUse.id ASSIGN expr.a SEMI {:return new Assignment(id,a);:};

param_list =   
       	param.a {: return new List().add(a); :}
        | param_list.a param.b {: return a.add(b); :}
        ;


arg_list =   
       	arg.a {: return new List().add(a); :}
        |  arg_list.a arg.b {: return a.add(b); :}
        ;


stmt_list =
	stmt.a {: return new List().add(a); :}
	| stmt_list.a stmt.b {: return a.add(b); :}
	;

func_list =
        function.a {: return new List().add(a); :}
        | func_list.a function.b {: return a.add(b); :}
        ;

	
mul = expr.a MUL expr.b {: return new Mul(a,b);:};
add = expr.a ADD expr.b {: return new Add(a,b);:};
sub = expr.a SUB expr.b {: return new Sub(a,b);:};
div = expr.a DIV expr.b {: return new Div(a,b);:};
mod = expr.a MOD expr.b {: return new Mod(a,b);:};
eq_expr = expr.a EQ expr.b {: return new Eq(a,b);:};
neq_expr = expr.a NEQ expr.b {: return new Neq(a,b);:};
gthn_expr = expr.a GTHN expr.b {: return new Gthn(a,b);:};
lthn_expr = expr.a LTHN expr.b {: return new Lthn(a,b);:};
geq_expr = expr.a GEQ expr.b {: return new Geq(a,b);:};
leq_expr = expr.a LEQ expr.b {:return new Leq(a,b);:};




expr = numeral | idUse | mul | add | sub | div | mod | eq_expr | neq_expr | gthn_expr | lthn_expr | geq_expr | leq_expr;
numeral = NUMERAL.num {:return new Numeral(num);:};
idUse = ID.id {:return new IdUse(id);:};


