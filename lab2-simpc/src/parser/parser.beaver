%class "LangParser";
%package "lang.ast";

%embed {:
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}
:};


%terminals ID, NUMERAL, ASSIGN, IF,ELSE, WHILE, INT, RETURN, COMMA;
//Structure terminals
%terminals LPAR, RPAR, LBRACKET, RBRACKET, SEMI;

//Arith terminals
%terminals ADD, SUB, MUL, DIV, MOD;

//Comparsion terminals
%terminals EQ, NEQ, LEQ, LTHN, GEQ, GTHN, SEMI;

%typeof program = "Program";
%typeof function = "Function";
%typeof paramFunc = "ParamFunc";
%typeof funcStmt = "FuncStmt";
%typeof func_list = "List";
%typeof stmt = "Stmt";
%typeof stmt_list = "List";
%typeof ifStmt = "IfStmt";
%typeof else = "ElseStmt";
%typeof whileStmt = "WhileStmt";
%typeof returnStmt = "ReturnStmt";
%typeof assign = "Assignment";
%typeof declare = "Declare";
%typeof expr ="Expr";
%typeof numeral = "Numeral";
%typeof idUse = "IdUse";
%typeof param = "Param";
%typeof param_list = "List";
%typeof arg_list = "List";
//%typeof idArg = "IdArg";
//%typeof funcArg = "FuncArg";
//%typeof term = "Term";
%typeof compare = "Compare";
%typeof plusminus = "PlusMinus";
%typeof divmult = "DivMult";
%typeof funccall = "FuncCall";
%typeof iddecl = "IdDecl";


%left  MUL, DIV, MOD, ADD, SUB, EQ, NEQ, LEQ, GEQ, LTHN, GTHN;

%goal program;

program = func_list.a {: return new Program(a); :};

function = paramFunc;

paramFunc = iddecl.id LPAR param_list.p RPAR LBRACKET stmt_list.t RBRACKET  {: return new ParamFunc(id,p,t); :};

funccall = idUse.id LPAR arg_list.l RPAR {:return new FuncCall(id,l);:};


/* GENERATES ERROR */
funcStmt = funccall.a {:return new FuncStmt(a);:};

stmt = ifStmt | whileStmt| declare | funcStmt | assign | returnStmt;

ifStmt = IF LPAR expr.a RPAR LBRACKET stmt_list.t RBRACKET else {:return new IfStmt(a,t);:};



param = iddecl.id {:return new Param(id);:}
	| COMMA iddecl.id {: return new Param(id);:}	
	;

param_list = param.a {: return new List().add(a); :}
        | param_list.a param.b {: return a.add(b); :}
        | {: return new List();:} /*Returns an empty list i.e no arguments*/
        ;




arg = 
	idUse.id {:return new IdUse(id);:}
	| funcStmt.t {:return new FuncStmt(t);:}
	| COMMA arg
	;


/****************Replaced by "arg" above*************************


arg = idArg | funcArg;

idArg = idUse.id {:return new IdUse(id);:}
	| COMMA idUse.id {:return new IdUse(id);:}
	;

funcArg = funcStmt.t {:return new FuncCall(t);:}
	| COMMA funcStmt.t {:return new FuncCall(t);:}
	;

**************************************************/

arg_list =
        arg.a {: return new List().add(a); :}
        |  arg_list.a arg.b {: return a.add(b); :}
        | {: return new List();:}
        ;




else=
	ELSE LBRACKET stmt_list.u RBRACKET {:return new ElseStmt(u);:}
	|
	;

whileStmt = WHILE LPAR expr.a RPAR LBRACKET stmt_list.t RBRACKET {:return new WhileStmt(a,t);:};

declare = iddecl.id SEMI {: return new Declare(id);:}
	| INT assign.a {: return new Declare(new Opt(a));:}
	;

returnStmt = RETURN stmt_list.a SEMI {: return new ReturnStmt(a);:};


assign = idUse.id ASSIGN expr.a SEMI {:return new Assignment(id,a);:};


stmt_list =
	stmt.a {: return new List().add(a); :}
	| stmt_list.a stmt.b {: return a.add(b); :}
	;

func_list =
        function.a {: return new List().add(a); :}
        | func_list.a function.b {: return a.add(b); :}
        ;


compare = expr.a EQ expr.b {: return new Eq(a,b);:}
	| expr.a NEQ expr.b {: return new Neq(a,b);:}
	| expr.a GTHN expr.b {: return new Gthn(a,b);:}
	| expr.a LTHN expr.b {: return new Lthn(a,b);:}
	| expr.a GEQ expr.b {: return new Geq(a,b);:}
	| expr.a LEQ expr.b {:return new Leq(a,b);:}
	;



plusminus = divmult.a ADD plusminus.b {:return new Add(a,b);:} 
	| divmult.a SUB plusminus.b {:return new Sub(a,b);:}  
	;

divmult = expr.a MUL divmult.b {:return new Mul(a,b);:}
	| expr.a DIV divmult.b {:return new Div(a,b);:}
	| expr.a MOD divmult.b {:return new Mod(a,b);:} 
	; 

term =  idUse | numeral | LPAR plusminus RPAR;

binary_expr = divmult | plusminus | compare;

expr = binary_expr | term | funccall;


numeral = NUMERAL.num {:return new Numeral(num);:};

idUse = ID.id {:return new IdUse(id);:};

/*XXX*/
iddecl = INT ID.id {:return new IdDecl(id);:}; 






//OLD SHIT
/*************************************
expr = divmult.a {:return new DivMult(a);:}
         | plusminus.a {:return new PlusMinus(a);:}
         | compare.a {:return new Compare(a);:}
         ;
***************************/

