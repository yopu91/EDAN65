/***************************************
Attribute grammars:
-- Expressing properties of methods/expressions/variables as ATTRIBUTES of AST nodes.
-- Define those ATTRIBUTES by EQUATIONS

- If the equation defines an attribute in the NODE - the attribute is synthesized
-- Synthesized attributes propagate information upwards in the AST
- If the equation defines an attribute in the CHILD - the attribute is inherited
-- Inherited attributes propagate information downwards in the AST



Tips:  localLookup should not call lookup. It should never do that, since localLookup looks for local declarations and
 not for declarations defined somewhere else (which is what lookup finds).
***************************************/



aspect NameAnalysis {

	syn IdDecl IdUse.decl() = lookup(getID());

	inh IdDecl IdUse.lookup(String name);

	inh IdDecl ParamFunc.lookup(String name); 
	
	inh IdDecl IdDecl.lookup(String name);

	inh IdDecl Stmt.lookup(String name);	

        syn IdDecl Stmt.localLookup(String name);

	inh IdDecl Expr.lookup(String name);



	eq Program.getChild().lookup(String name){
		return unknownDecl();
	}
	
	eq Program.getParamFunc(int index).lookup(String name){
		return getParamFunc(index).localLookup(name);
	}


/*
Declare:Stmt ::= Identifier:IdDecl [Expr];
*/

	syn IdDecl Declare.localLookup(String name){
		System.out.println("In Declare.localLookup("+name+")");
		
		if(getIdentifier().getID().equals(name)){
			return getIdentifier();
		}

		if (hasExpr()){
/*
			if(getExpr().getIdentifier().getID().equals(name)){
				return getExpr().getIdentifier();
			}
*/
			System.out.println("Decl has expr.");
		}

		return unknownDecl();
	}

/*
Assignment:Stmt ::= Identifier:IdUse Expression:Expr;
*/

        syn IdDecl Assignment.localLookup(String name){
                System.out.println("In Assignment.localLookup("+name+")");
                if(getIdentifier().getID().equals(name)){
//                      return lookup(getIdentifier().getID());  
			return getIdentifier().decl(); //Correct?
                }

/*
		Expr expression = getExpression();
		IdDecl decl = expression.localLookup(name);
		return !decl.isUnknown() ;
*/
                return unknownDecl();

        }


/*
WhileStmt:Stmt ::= Cond:Expr Stmt*;
*/

        syn IdDecl WhileStmt.localLookup(String name){
                System.out.println("In WhileStmt.localLookup("+name+") --> Returning unknownDecl()");		
		return unknownDecl();
        }
	

        syn IdDecl IfStmt.localLookup(String name){
                System.out.println("In IfStmt.localLookup("+name+") --> Returning unknownDecl()");
                return unknownDecl();
        }

        syn IdDecl ElseStmt.localLookup(String name){
                System.out.println("In ElseStmt.localLookup("+name+") --> Returning unknownDecl()");
                return unknownDecl();
        }

        syn IdDecl ReturnStmt.localLookup(String name){
                System.out.println("In ReturnStmt.localLookup("+name+") ");
                return unknownDecl();
        }

        syn IdDecl FuncStmt.localLookup(String name){
                System.out.println("In FuncStmt.localLookup("+name+")");
                return unknownDecl();
        }

	syn IdDecl FuncCall.localLookup(String name){
                System.out.println("In FuncCall.localLookup("+name+")");
		return unknownDecl();
	}
	
	syn IdDecl Numeral.localLookup(String name){
                System.out.println("In FuncStmt.localLookup("+name+")");
		return unknownDecl();
	}
	

	syn IdDecl BinaryExpr.localLookup(String name){
                System.out.println("In BinaryExpr.localLookup("+name+")");
		return unknownDecl();
	}








/* Interesting methods in ParamFunc:
	getName() -> IdDecl
	getNumParams() -> int
	getParams(int index) -> Param
	hasParams() -> bool
	hasStmts() -> bool
	getNumStmts() -> int
	getStmts(int index) -> Stmt
*/

	syn IdDecl ParamFunc.localLookup(String name){

		System.out.println("In ParamFunc.localLookup("+name+")");
		//CHECK NAME OF paRAMFUNC

		if(getName().getID().equals(name)){
			System.out.println("	Returning:"+getName().getID()+" (when checking name of ParamFunc)");
			return getName();
		}

		//CHECK ALL PARAMS of PARAMFUNC

		for (int i =0; i<getNumParams(); i++){
			if(getParams(i).getIdDecl().getID().equals(name)){
				System.out.println("	Returning: "+ getParams(i).getIdDecl().getID()+" (when checking Params of ParamFunc)");
				return getParams(i).getIdDecl();
			}
		}

		//For each Stmt in the paramfunc --> call that particular statements locallookup

		for (int j=0; j<getNumStmts(); j++){
			System.out.println("Should be entering lookup for: "+getStmts(j).getClass().getName());
			IdDecl decl = getStmts(j).localLookup(name);
			System.out.println("	Returning: "+decl.getID()+"after getStmts("+j+").localLookup("+name+")");
			return !decl.isUnknown() ? decl : lookup(name);
		}

		System.out.println("	Returning: unknownDecl()");
		return unknownDecl();
	} //END of ParamFunc.localLookup();





	syn boolean IdDecl.isMultiplyDeclared() {

		if(lookup(getID()).isUnknown()){
			System.out.println("	isMultiplyDeclared() returned FALSE when looking up "+getID()+" (getID -> isUnknown())");
			return false;
		}
		if(lookup(getID()) == this){
			System.out.println("	isMultiplyDeclared() returned FALSE when looking up "+getID()+" (getID -> this)");
			return false;
		}
                System.out.println("		isMultiplyDeclared() returned TRUE when looking up "+getID()+" (neither unknown or this)");
		return true;
	}




}

aspect CircularDefinitions {
	syn boolean IdUse.isCircular() { 
		return inExprOf(decl());
	}
	inh boolean IdUse.inExprOf(IdDecl decl);
	eq Program.getChild().inExprOf(IdDecl decl) {
		System.out.println("	Returning false for Program.getChild().inExprOf( "+ decl.getID());		
		return false;
	}	
		
}

