/***************************************
Attribute grammars:
-- Expressing properties of methods/expressions/variables as ATTRIBUTES of AST nodes.
-- Define those ATTRIBUTES by EQUATIONS

- If the equation defines an attribute in the NODE - the attribute is synthesized
-- Synthesized attributes propagate information upwards in the AST
- If the equation defines an attribute in the CHILD - the attribute is inherited
-- Inherited attributes propagate information downwards in the AST



Tips:  localLookup should not call lookup. It should never do that, since localLookup looks for local declarations and
 not for declarations defined somewhere else (which is what lookup finds).


The only declarations we are interested in are
int FFF (int a)
	int b

FFF, a and b


TA bort lookups i assignments och dylikt. Det är bara i decl, paramfunc och params som det är intressant --> allt annat är överflödigt
***************************************/



aspect NameAnalysis {

	syn IdDecl IdUse.decl() = lookup(getID());

	inh IdDecl IdUse.lookup(String name);



	inh IdDecl ParamFunc.lookup(String name); 
	
	inh IdDecl IdDecl.lookup(String name);

	inh IdDecl Stmt.lookup(String name);	

        syn IdDecl Stmt.localLookup(String name);

	inh IdDecl Expr.lookup(String name);

	syn IdDecl Expr.localLookup(String name);

	syn IdDecl IdUse.localLookup(String name) {
		System.out.println("TEA AND BISCUITS!!!");
		return unknownDecl();
	}


/*Checks for declarations of method-names*/
	eq Program.getChild().lookup(String name){
		for(int i = 0; i<getNumParamFunc(); i++){
			IdDecl decl = getParamFunc(i).getName();
			if(decl.getID().equals(name)){
				return decl;
			}
		}
		return unknownDecl();
	}
	/*
	eq Program.getParamFunc(int index).lookup(String name){
		return getParamFunc(index).localLookup(name);
	}
*/

/*
Declare:Stmt ::= Identifier:IdDecl [Expr];
*/

	syn IdDecl Declare.localLookup(String name){
		System.out.println("In Declare.localLookup("+name+")");
		
		if(getIdentifier().getID().equals(name)){
			return getIdentifier();
		}

		return unknownDecl();
	}


/*
Assignment:Stmt ::= Identifier:IdUse Expression:Expr;
*/

        syn IdDecl Assignment.localLookup(String name){
                System.out.println("In Assignment.localLookup("+name+")");

                if(getIdentifier().getID().equals(name)){
			IdDecl decl = getIdentifier().decl();
			return decl.isUnknown() ? decl : lookup(name); //getIdentifier().decl(); //Correct?
                }

/*
		Expr expression = getExpression();
		IdDecl decl = expression.localLookup(name);
		return !decl.isUnknown() ? decl : lookup(name) ;
*/

		return unknownDecl();
        }


/*
WhileStmt:Stmt ::= Cond:Expr Stmt*;
*/

        syn IdDecl WhileStmt.localLookup(String name){
                System.out.println("In WhileStmt.localLookup("+name+") --> Returning unknownDecl()");		
		return unknownDecl();
        }
	

        syn IdDecl IfStmt.localLookup(String name){
                System.out.println("In IfStmt.localLookup("+name+") --> Returning unknownDecl()");
                return unknownDecl();
        }

        syn IdDecl ElseStmt.localLookup(String name){
                System.out.println("In ElseStmt.localLookup("+name+") --> Returning unknownDecl()");
                return unknownDecl();
        }

        syn IdDecl ReturnStmt.localLookup(String name){
                System.out.println("In ReturnStmt.localLookup("+name+") ");
                return unknownDecl();
        }

        syn IdDecl FuncStmt.localLookup(String name){
                System.out.println("In FuncStmt.localLookup("+name+")");
                return unknownDecl();
        }

	syn IdDecl FuncCall.localLookup(String name){
                System.out.println("In FuncCall.localLookup("+name+")");
		return unknownDecl();
	}
	
	syn IdDecl Numeral.localLookup(String name){
                System.out.println("In FuncStmt.localLookup("+name+")");
		return unknownDecl();
	}
	

	syn IdDecl BinaryExpr.localLookup(String name){
                System.out.println("In BinaryExpr.localLookup("+name+")");
		return unknownDecl();
	}








/* Interesting methods in ParamFunc:
	getName() -> IdDecl
	getNumParams() -> int
	getParams(int index) -> Param
	hasParams() -> bool
	hasStmts() -> bool
	getNumStmts() -> int
	getStmts(int index) -> Stmt
*/


	syn IdDecl ParamFunc.localLookup(String name){

		System.out.println("In ParamFunc.localLookup("+name+")");
		//CHECK NAME OF paRAMFUNC

		if(getName().getID().equals(name)){
			System.out.println("	Returning:"+getName().getID()+" (when checking name of ParamFunc)");
			return getName();
		}

		//CHECK ALL PARAMS of PARAMFUNC

		for (int i =0; i<getNumParams(); i++){
			if(getParams(i).getIdDecl().getID().equals(name)){
				System.out.println("	Returning: "+ getParams(i).getIdDecl().getID()+" (when checking Params of ParamFunc)");
				return getParams(i).getIdDecl();
			}
		}

		//For each Stmt in the paramfunc --> call that particular statements locallookup

		for (int j=0; j<getNumStmts(); j++){
					System.out.println("Should be entering lookup for: "+getStmts(j).getClass().getName());
			IdDecl decl = getStmts(j).localLookup(name);
					System.out.println("	Returning: "+decl.getID()+"after getStmts("+j+").localLookup("+name+")");
//			return !decl.isUnknown() ? decl : lookup(name);
			return decl;
		}

		System.out.println("	Returning: unknownDecl() at end of ParamFunc.localLookup()");
		return unknownDecl();
	} //END of ParamFunc.localLookup();





	syn boolean IdDecl.isMultiplyDeclared() {

		if(lookup(getID()).isUnknown()){
			System.out.println("	isMultiplyDeclared() returned FALSE when looking up "+getID()+" (getID -> isUnknown())");
			return false;
		}
		if(lookup(getID()) == this){
			System.out.println("	isMultiplyDeclared() returned FALSE when looking up "+getID()+" (getID -> this)");
			return false;
		}
                System.out.println("		isMultiplyDeclared() returned TRUE when looking up "+getID()+" (neither unknown or this)");
		return true;
	}




}

aspect CircularDefinitions {
	syn boolean IdUse.isCircular() { 
		return inExprOf(decl());
	}
	inh boolean IdUse.inExprOf(IdDecl decl);
	eq Program.getChild().inExprOf(IdDecl decl) {
		System.out.println("	Returning false for Program.getChild().inExprOf( "+ decl.getID()+")");		
		return false;
	}
/*	eq Assignment.getIdentifier().inExprOf(IdDecl decl){
		if(decl == getIdentifier().decl()){
			return true;
		}
		return false;
	}	
*/
		
}




/**************************************************************************************

Program ::= ParamFunc*;
ParamFunc               ::= Name:IdDecl Params:Param* Stmts:Stmt*;
Param                   ::= IdDecl;

abstract Stmt;

WhileStmt:Stmt          ::= Cond:Expr Stmt*;
IfStmt:Stmt             ::= Cond:Expr Then:Stmt* [ElseStmt];
ElseStmt:Stmt           ::= Stmt*;
ReturnStmt:Stmt         ::= Expr;
FuncCall:Expr           ::= Name:IdUse E:Expr*;

FuncStmt:Stmt           ::= FuncCall;


Assignment:Stmt         ::= Identifier:IdUse Expression:Expr;
Declare:Stmt            ::= Identifier:IdDecl [Expr];

abstract Expr;
Numeral:Expr            ::= <NUMERAL>;
IdUse:Expr              ::= <ID>; 
IdDecl                  ::= <ID>; 

UnknownDecl : IdDecl;

BinaryExpr:Expr         ::= Left:Expr Right:Expr;
Add:BinaryExpr;
Sub:BinaryExpr;
Div:BinaryExpr;
Mul:BinaryExpr;
Mod:BinaryExpr;

Neq:BinaryExpr;
Eq:BinaryExpr;
Leq:BinaryExpr;
Lthn:BinaryExpr;
Geq:BinaryExpr;
Gthn:BinaryExpr;

*******************************************************/

