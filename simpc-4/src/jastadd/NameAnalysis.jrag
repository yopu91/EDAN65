aspect NameAnalysis {
	syn IdDecl IdUse.decl() = lookup(getID());
	inh IdDecl IdUse.lookup(String name);

	inh IdDecl ParamFunc.lookup(String name); 
	
	inh IdDecl IdDecl.lookup(String name);

	inh IdDecl Stmt.lookup(String name);
	
	eq Program.getChild().lookup(String name) { 
		System.out.println("\nIn Program.getChild().lookup("+name+")\n");
		return unknownDecl(); 
	}

	eq ParamFunc.getStmts(int index).lookup(String name){
		System.out.println("In ParamFunc.getStmts("+index+").lookup("+name+")");
		IdDecl decl = localLookup(name); //ParamFunc.localLookup
		return !decl.isUnknown() ? decl : lookup(name);
	}

	syn IdDecl Declare.localLookup(String name){
		System.out.println("In Declare.localLookup("+name+")");
		if(getIdentifier().getID().equals(name)){
			return getIdentifier();
		}
		return unknownDecl();
	}

        syn IdDecl Assignment.localLookup(String name){
                System.out.println("In Assignment.localLookup("+name+")");
                return null;
        }

        syn IdDecl WhileStmt.localLookup(String name){
                System.out.println("In WhileStmt.localLookup("+name+")");
                return null;
        }

        syn IdDecl IfStmt.localLookup(String name){
                System.out.println("In IfStmt.localLookup("+name+")");
                return null;
        }

        syn IdDecl ElseStmt.localLookup(String name){
                System.out.println("In ElseStmt.localLookup("+name+")");
                return null;
        }

        syn IdDecl ReturnStmt.localLookup(String name){
                System.out.println("In ReturnStmt.localLookup("+name+")");
                return null;
        }

        syn IdDecl FuncStmt.localLookup(String name){
                System.out.println("In FuncStmt.localLookup("+name+")");
                return null;
        }


	//Generic localLookup for all classes implementing "Stmt". 
	syn IdDecl Stmt.localLookup(String name);

/* Interesting methods in ParamFunc:
	getName() -> IdDecl
	getNumParams() -> int
	getParams(int index) -> Param
	hasParams() -> bool
	hasStmts() -> bool
	getNumStmts() -> int
	getStmts(int index) -> Stmt
*/

	syn IdDecl ParamFunc.localLookup(String name){

		System.out.println("In ParamFunc.localLookup("+name+")");


		//CHECK NAME OF paRAMFUNC

		if(getName().getID().equals(name)){
			System.out.println("	Returning:"+getName().getID());
			return getName();
		}


		//CHECK ALL PARAMS of PARAMFUNC

		for (int i =0; i<getNumParams(); i++){
			if(getParams(i).getIdDecl().getID().equals(name)){
				System.out.println("	Returning: "+ getParams(i).getIdDecl().getID());
				return getParams(i).getIdDecl();
			}
		}

		//For each Stmt in the paramfunc --> call that particular statements locallookup
		//problematic with "getStmts(j).lookup(name);" since it looks for the method in the abstract class Stmt

		for (int j=0; j<getNumStmts(); j++){
			IdDecl decl = getStmts(j).localLookup(name);
			System.out.println("	Returning: "+decl.getID());
			return !decl.isUnknown() ? decl : lookup(name);
		}
		System.out.println("	Returning: unknownDecl()");
		return unknownDecl();
	}

	syn boolean IdDecl.isMultiplyDeclared() {

		if(lookup(getID()).isUnknown()){
			System.out.println("	isMultiplyDeclared() returned FALSE when looking up "+getID()+" (getID -> isUnknown())");
			return false;
		}
		if(lookup(getID()) == this){
			System.out.println("	isMultiplyDeclared() returned FALSE when looking up "+getID()+" (getID -> this)");
			return false;
		}
                System.out.println("		isMultiplyDeclared() returned TRUE when looking up "+getID()+" (neither unknown or this)");
		return true;
	}
}

aspect CircularDefinitions {
	/* Identify circular definitions in let expressions */
	syn boolean IdUse.isCircular() = inExprOf(decl());
	inh boolean IdUse.inExprOf(IdDecl decl);
	eq Program.getChild().inExprOf(IdDecl decl) = false;
}

