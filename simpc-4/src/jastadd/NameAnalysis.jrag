aspect NameAnalysis {
	syn IdDecl IdUse.decl() = lookup(getID());
	inh IdDecl IdUse.lookup(String name);
	inh IdDecl Stmt.lookup(String name); //This is needed so that the lookup-function can be called in all classes extending "Stmt"
//	inh IdDecl Stmt.getStmt(int index).lookup(String name);

	eq Assignment.getExpression().lookup(String name) {
		IdDecl decl = lookup(name);
		return !decl.isUnknown() ? decl : lookup(name);
	}
	
	eq WhileStmt.getCond().lookup(String name) {
		IdDecl decl = lookup(name);
		return !decl.isUnknown() ? decl : lookup(name);
	}

        eq IfStmt.getCond().lookup(String name) {
                IdDecl decl = lookup(name);
                return !decl.isUnknown() ? decl : lookup(name);
        }
	
	eq ElseStmt.getStmt(int index).lookup(String name) {
		//what the fuck is going on here
		for (int i = 0; i<getNumStmt(); i++){
			if( getStmt(i).lookup(name).equals(name)){
				//WHAT?
				return getStmt(i).lookup(name);
			}
		}
		return unknownDecl();
	}
/*************LIKE THIS FOR ALL STMTS???
	eq IfStmt.getStmt(int index).lookup(String name) {

	}
*/
	

/*
	eq Stmt.lookup(String name){
		for (int i=0; i<getNumStmt(); i++){
			if(getStmt(i).lookup(name)){
				
			}
		}
	}
*/
	eq Program.getChild().lookup(String name) = unknownDecl();
	inh IdDecl IdDecl.lookup(String name);
	syn boolean IdDecl.isMultiplyDeclared() = lookup(getID()) != this;
}

aspect CircularDefinitions {
	/* Identify circular definitions in let expressions */
	syn boolean IdUse.isCircular() = inExprOf(decl());
	inh boolean IdUse.inExprOf(IdDecl decl);
/*
	inh boolean Assignment.inExprOf(IdUse use);
	eq Assignment.getExpression().inExprOf(IdUse use) = getIdentifier() == use || inExprOf(use);
*/
	eq Program.getChild().inExprOf(IdDecl decl) = false;
}
