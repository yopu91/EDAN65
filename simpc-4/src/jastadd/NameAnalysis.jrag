/***************************************
Attribute grammars:
-- Expressing properties of methods/expressions/variables as ATTRIBUTES of AST nodes.
-- Define those ATTRIBUTES by EQUATIONS

- If the equation defines an attribute in the NODE - the attribute is synthesized
- If the equation defines an attribute in the CHILD - the attribute is inherited

***************************************/



aspect NameAnalysis {

	syn IdDecl IdUse.decl() = lookup(getID());
	inh IdDecl IdUse.lookup(String name);

	inh IdDecl ParamFunc.lookup(String name); 
	
	inh IdDecl IdDecl.lookup(String name);

	inh IdDecl Stmt.lookup(String name);	
        //Generic localLookup for all classes implementing "Stmt".
        syn IdDecl Stmt.localLookup(String name);


	eq Program.getParamFunc(int index).lookup(String name) { 
		System.out.println("\nIn Program.getParamFunc("+index+").lookup("+name+")\n");

		//Using any of these two return statements results in circularity
		return getParamFunc(index).localLookup(name);
		//return getParamFunc(index).lookup(name);
	}

/* This method is only invoked when one of the children are unknownDecl() otherwise it goes to Program.getParamFunc(...-method.
If this is removed or commented away then the compiler throws a WARNING, but that's about it */
	eq Program.getChild().lookup(String name){
		System.out.println("\nIn Program.getChild().lookup("+name+")\n");
		return unknownDecl();
	}


	eq ParamFunc.getStmts(int index).lookup(String name){

		System.out.println("In ParamFunc.getStmts("+index+").lookup("+name+")");

		IdDecl decl = localLookup(name); //ParamFunc.localLookup
		return !decl.isUnknown() ? decl : lookup(name);
	}


	syn IdDecl Declare.localLookup(String name){
		System.out.println("In Declare.localLookup("+name+")");
		if(getIdentifier().getID().equals(name)){
			return getIdentifier();
		}
		return unknownDecl();
	}
	
	eq Declare.getIdentifier().lookup(String name){
		IdDecl decl = localLookup(name);
		return !decl.isUnknown() ? decl : lookup(name);
	}
	
	eq Declare.getExpr().lookup(String name){
		IdDecl decl = localLookup(name);
		return !decl.isUnknown() ? decl : lookup(name);
	}




        syn IdDecl Assignment.localLookup(String name){
                System.out.println("In Assignment.localLookup("+name+")");
                return null;
        }

        syn IdDecl WhileStmt.localLookup(String name){
                System.out.println("In WhileStmt.localLookup("+name+")");
                return null;
        }

        syn IdDecl IfStmt.localLookup(String name){
                System.out.println("In IfStmt.localLookup("+name+")");
                return null;
        }

        syn IdDecl ElseStmt.localLookup(String name){
                System.out.println("In ElseStmt.localLookup("+name+")");
                return null;
        }

        syn IdDecl ReturnStmt.localLookup(String name){
                System.out.println("In ReturnStmt.localLookup("+name+")");
                return null;
        }

        syn IdDecl FuncStmt.localLookup(String name){
                System.out.println("In FuncStmt.localLookup("+name+")");
                return null;
        }






/* Interesting methods in ParamFunc:
	getName() -> IdDecl
	getNumParams() -> int
	getParams(int index) -> Param
	hasParams() -> bool
	hasStmts() -> bool
	getNumStmts() -> int
	getStmts(int index) -> Stmt
*/

	syn IdDecl ParamFunc.localLookup(String name){

		System.out.println("In ParamFunc.localLookup("+name+")");
		//CHECK NAME OF paRAMFUNC

		if(getName().getID().equals(name)){
			System.out.println("	Returning:"+getName().getID()+" (when checking name of ParamFunc)");
			return getName();
		}


		//CHECK ALL PARAMS of PARAMFUNC

		for (int i =0; i<getNumParams(); i++){
			if(getParams(i).getIdDecl().getID().equals(name)){
				System.out.println("	Returning: "+ getParams(i).getIdDecl().getID()+" (when checking Params of ParamFunc)");
				return getParams(i).getIdDecl();
			}
		}

		//For each Stmt in the paramfunc --> call that particular statements locallookup
		//problematic with "getStmts(j).lookup(name);" since it looks for the method in the abstract class Stmt --> solved by inh-equation above

		for (int j=0; j<getNumStmts(); j++){
			System.out.println("Should be entering lookup for: "+getStmts(j).getClass().getName());
			IdDecl decl = getStmts(j).localLookup(name);
			System.out.println("	Returning: "+decl.getID());
			return !decl.isUnknown() ? decl : lookup(name);
		}
		System.out.println("	Returning: unknownDecl()");
		return unknownDecl();
	}

	syn boolean IdDecl.isMultiplyDeclared() {

		if(lookup(getID()).isUnknown()){
			System.out.println("	isMultiplyDeclared() returned FALSE when looking up "+getID()+" (getID -> isUnknown())");
			return false;
		}
		if(lookup(getID()) == this){
			System.out.println("	isMultiplyDeclared() returned FALSE when looking up "+getID()+" (getID -> this)");
			return false;
		}
                System.out.println("		isMultiplyDeclared() returned TRUE when looking up "+getID()+" (neither unknown or this)");
		return true;
	}
}

aspect CircularDefinitions {
	syn boolean IdUse.isCircular() { 
		return inExprOf(decl());
	}
	inh boolean IdUse.inExprOf(IdDecl decl);
	eq Program.getChild().inExprOf(IdDecl decl) {
		System.out.println("	Returning false for Program.getChild().inExprOf( "+ decl.getID());		
		return false;
	}	
		
}

