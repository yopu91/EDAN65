package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short NUMERAL = 2;
		static public final short INT = 3;
		static public final short BOOL = 4;
		static public final short IF = 5;
		static public final short WHILE = 6;
		static public final short RETURN = 7;
		static public final short ADD = 8;
		static public final short SUB = 9;
		static public final short LPAR = 10;
		static public final short SEMI = 11;
		static public final short RPAR = 12;
		static public final short LBRACKET = 13;
		static public final short RBRACKET = 14;
		static public final short MUL = 15;
		static public final short DIV = 16;
		static public final short MOD = 17;
		static public final short ASSIGN = 18;
		static public final short COMMA = 19;
		static public final short ELSE = 20;
		static public final short EQ = 21;
		static public final short NEQ = 22;
		static public final short GTHN = 23;
		static public final short LTHN = 24;
		static public final short GEQ = 25;
		static public final short LEQ = 26;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"NUMERAL",
			"INT",
			"BOOL",
			"IF",
			"WHILE",
			"RETURN",
			"ADD",
			"SUB",
			"LPAR",
			"SEMI",
			"RPAR",
			"LBRACKET",
			"RBRACKET",
			"MUL",
			"DIV",
			"MOD",
			"ASSIGN",
			"COMMA",
			"ELSE",
			"EQ",
			"NEQ",
			"GTHN",
			"LTHN",
			"GEQ",
			"LEQ"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9ojbibpLKKKXt$zNcB2Is9G22AGa1WH8OaWI2GaO4061GLa43GoHA2qhBAiiiegNLZbngK" +
		"Rgzp8F#5GvL8tid76UK9nH9m54GVm#7NV1llTtBmizAQ#Fhy#vtRtUNrxYEJkrrRThYMwHe" +
		"kqM5TejrfqeLerMHVfuX2hw6gjqAh2sFGQiVOQiSjrXtPf2x7cCJ6VotKXb#BOzUF4V8yhD" +
		"JmcvjkifirozLRfUZCDQYYqkq1hWfwaQrMdPUEsAMkgsdXlWTQ6iRhGQRnHVRf1wtMJDcgp" +
		"zcX#BfxgAtM9jXFt$KpJFEqCUcR8PufcQyVvjnVYRohmhyD$QU8V3NrbkNKa$dt1tw0Ps3c" +
		"9VwMMLjK6gcgp2aPShgiIVMEYDoJwvaHlIlGjpAtFf8XExG$sCfNifVFpEv7j3#LeN4tTsg" +
		"Qvwh4VrMy$w5RjnNURHdGdipehqCwyT356Dojm3YjbBb$1#tlYQlb$OsL#hokCrSgbLYphi" +
		"LGOysrcCu#fxfLOMVD3kmhVpkiMTdeNUhms2tZJlzV8Rl1ZUPt6cza1qrYxqrbxCrWV#NYg" +
		"cnZDntq$pUp5J4yD#TIpwngIjnrxTc9$L#WhootrzmN$GiwSQhzZtBGsfQhMKZXYvt$IMOP" +
		"5L9ZRR2OMioVEpUz4jXA$UFRjMvZ5NkRL1NzJ#DrD$FalVU0HXMSfF1pr43m8e$0aF0Idu9" +
		"2FruBdCTydF0TFmHau3C$6k4ckZ3sIrTq0nK7i8Eo42lNZCRQFukdOxWNgkw9#7Bw2e$0Bb" +
		"8ZrL#VXzeB$JITYVLakpyduXd9jLkJgmnGTsDMm2ZR0MjW4ws4hR8GTi2MssGOZC1hhks5$" +
		"r76ktTrmJzHxehrtx5owDegxOhwRettnNDpC$1oqvziLmNDVqkuafYVjomy60qdzWKItmhg" +
		"Oqs3YVpGtnkbedudZ72l8OtkYHmhYVRdwOAx#VBHdOpxbQ2T5snfjMwxT4ua#c1#t#bqt7E" +
		"sQN1y7CcD7G$cpucD$s#Vsb$rfVzZlTjf#K$BOAVirgkDL$cz2UIoKNzi7b9$2U$2slM6ls" +
		"slsBVeiV6S$sVls3kejUzLUmRvfX#rxxBlm2Ho1Z#4Z#D1UZYDy6KhMY9q9wWjWjzX9Es6V" +
		"uV1thEDqQUGSgkC#A74$k4AwEUcwm$yf$hHqK0Pn7xXmSdaM1SeWpjCwxfa6Rfeor7FRbBb" +
		"pwbXp3agSP0vAuOufOXvnJoSwmt5AbXCS9#U$TC1Cw8Kb$m0CnKKS");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = func_list.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
				}
			},
			new Action() {	// [1] paramFunc = type_id.type iddecl.id LPAR param_list.p RPAR LBRACKET stmt_list.t RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeId type = (TypeId) _symbol_type.value;
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_t = _symbols[offset + 7];
					final List t = (List) _symbol_t.value;
					 return new ParamFunc(type,id,p,t);
				}
			},
			new Action() {	// [2] funccall = idUse.id LPAR arg_list.l RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					return new FuncCall(id,l);
				}
			},
			new Action() {	// [3] funcStmt = funccall.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final FuncCall a = (FuncCall) _symbol_a.value;
					return new FuncStmt(a);
				}
			},
			Action.RETURN,	// [4] stmt = ifStmt
			Action.RETURN,	// [5] stmt = whileStmt
			Action.RETURN,	// [6] stmt = declare
			Action.RETURN,	// [7] stmt = assign
			Action.RETURN,	// [8] stmt = returnStmt
			Action.RETURN,	// [9] stmt = funcStmt
			new Action() {	// [10] ifStmt = IF LPAR expr.a RPAR LBRACKET stmt_list.t RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final List t = (List) _symbol_t.value;
					return new IfStmt(a,t, new Opt());
				}
			},
			new Action() {	// [11] ifStmt = IF LPAR expr.a RPAR LBRACKET stmt_list.t RBRACKET else.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final List t = (List) _symbol_t.value;
					final Symbol _symbol_e = _symbols[offset + 8];
					final ElseStmt e = (ElseStmt) _symbol_e.value;
					return new IfStmt(a,t, new Opt(e));
				}
			},
			new Action() {	// [12] param = type_id.type iddecl.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeId type = (TypeId) _symbol_type.value;
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					 return new Param(type, id);
				}
			},
			new Action() {	// [13] param_list = param.par
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_par = _symbols[offset + 1];
					final Param par = (Param) _symbol_par.value;
					 return new List().add(par);
				}
			},
			new Action() {	// [14] param_list = param_list.a COMMA param.par
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_par = _symbols[offset + 3];
					final Param par = (Param) _symbol_par.value;
					 return a.add(par);
				}
			},
			new Action() {	// [15] param_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			Action.RETURN,	// [16] arg = expr
			new Action() {	// [17] type_id = INT.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol t = _symbols[offset + 1];
					 return new IntType(t);
				}
			},
			new Action() {	// [18] type_id = BOOL.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol t = _symbols[offset + 1];
					 return new BoolType(t);
				}
			},
			new Action() {	// [19] arg_list = arg.ar
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ar = _symbols[offset + 1];
					final Expr ar = (Expr) _symbol_ar.value;
					 return new List().add(ar);
				}
			},
			new Action() {	// [20] arg_list = arg_list.a COMMA arg.ar
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_ar = _symbols[offset + 3];
					final Expr ar = (Expr) _symbol_ar.value;
					 return a.add(ar);
				}
			},
			new Action() {	// [21] arg_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			new Action() {	// [22] else = ELSE LBRACKET stmt_list.u RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_u = _symbols[offset + 3];
					final List u = (List) _symbol_u.value;
					return new ElseStmt(u);
				}
			},
			new Action() {	// [23] whileStmt = WHILE LPAR expr.a RPAR LBRACKET stmt_list.t RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final List t = (List) _symbol_t.value;
					return new WhileStmt(a,t);
				}
			},
			new Action() {	// [24] declare = type_id.type iddecl.id SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeId type = (TypeId) _symbol_type.value;
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					 return new Declare(type,id, new Opt());
				}
			},
			new Action() {	// [25] declare = type_id.type iddecl.id ASSIGN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeId type = (TypeId) _symbol_type.value;
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final Expr a = (Expr) _symbol_a.value;
					 return new Declare(type,id,new Opt(a));
				}
			},
			new Action() {	// [26] returnStmt = RETURN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new ReturnStmt(a);
				}
			},
			new Action() {	// [27] assign = idUse.id ASSIGN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					return new Assignment(id,a);
				}
			},
			new Action() {	// [28] stmt_list = stmt.st
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_st = _symbols[offset + 1];
					final Stmt st = (Stmt) _symbol_st.value;
					 return new List().add(st);
				}
			},
			new Action() {	// [29] stmt_list = stmt_list.a stmt.st
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_st = _symbols[offset + 2];
					final Stmt st = (Stmt) _symbol_st.value;
					 return a.add(st);
				}
			},
			new Action() {	// [30] func_list = paramFunc.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 1];
					final ParamFunc func = (ParamFunc) _symbol_func.value;
					 return new List().add(func);
				}
			},
			new Action() {	// [31] func_list = func_list.a paramFunc.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_func = _symbols[offset + 2];
					final ParamFunc func = (ParamFunc) _symbol_func.value;
					 return a.add(func);
				}
			},
			new Action() {	// [32] compare = sum.a EQ sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Eq(a,b);
				}
			},
			new Action() {	// [33] compare = sum.a NEQ sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Neq(a,b);
				}
			},
			new Action() {	// [34] compare = sum.a GTHN sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Gthn(a,b);
				}
			},
			new Action() {	// [35] compare = sum.a LTHN sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Lthn(a,b);
				}
			},
			new Action() {	// [36] compare = sum.a GEQ sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Geq(a,b);
				}
			},
			new Action() {	// [37] compare = sum.a LEQ sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					return new Leq(a,b);
				}
			},
			Action.RETURN,	// [38] expr = sum
			Action.RETURN,	// [39] expr = compare
			new Action() {	// [40] sum = sum.a ADD term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Add(a, b);
				}
			},
			new Action() {	// [41] sum = sum.a SUB term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a, b);
				}
			},
			Action.RETURN,	// [42] sum = term
			new Action() {	// [43] term = term.a MUL factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a, b);
				}
			},
			new Action() {	// [44] term = term.a DIV factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a, b);
				}
			},
			new Action() {	// [45] term = term.a MOD factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a, b);
				}
			},
			Action.RETURN,	// [46] term = factor
			Action.RETURN,	// [47] factor = numeral
			Action.RETURN,	// [48] factor = funccall
			Action.RETURN,	// [49] factor = idUse
			new Action() {	// [50] numeral = NUMERAL.num
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol num = _symbols[offset + 1];
					return new Numeral(num);
				}
			},
			new Action() {	// [51] idUse = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					return new IdUse(id);
				}
			},
			new Action() {	// [52] iddecl = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					return new IdDecl(id);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
