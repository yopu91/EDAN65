package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short NUMERAL = 2;
		static public final short INT = 3;
		static public final short IF = 4;
		static public final short WHILE = 5;
		static public final short RETURN = 6;
		static public final short ADD = 7;
		static public final short SUB = 8;
		static public final short LPAR = 9;
		static public final short SEMI = 10;
		static public final short RPAR = 11;
		static public final short LBRACKET = 12;
		static public final short RBRACKET = 13;
		static public final short MUL = 14;
		static public final short DIV = 15;
		static public final short MOD = 16;
		static public final short ASSIGN = 17;
		static public final short COMMA = 18;
		static public final short ELSE = 19;
		static public final short EQ = 20;
		static public final short NEQ = 21;
		static public final short GTHN = 22;
		static public final short LTHN = 23;
		static public final short GEQ = 24;
		static public final short LEQ = 25;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"NUMERAL",
			"INT",
			"IF",
			"WHILE",
			"RETURN",
			"ADD",
			"SUB",
			"LPAR",
			"SEMI",
			"RPAR",
			"LBRACKET",
			"RBRACKET",
			"MUL",
			"DIV",
			"MOD",
			"ASSIGN",
			"COMMA",
			"ELSE",
			"EQ",
			"NEQ",
			"GTHN",
			"LTHN",
			"GEQ",
			"LEQ"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9obbSTJ544Knh$U0H5qLL1G2KfGuYw264655ObY5dFMarTFdlHWbHVBVy3IYt#3Dwlqe6L" +
		"PPOwOCEUSiyzlcjwXcPtrucpzvdtTh$kzjpFTFO1QXMLOWwcOWicempg4CGp3CGAPoDAU3D" +
		"HY3kO6UCOazHG4Uc9emWITQHuppKR4qjNOWWRCmZI4v0nQt2WYc8xbIC7GXFZkl4RE2$Oq1" +
		"tesw$nfFazmDH5cTQjnPpYeHpPrif5BKKJl9BJgqPM#aQc8eXsTwC92B4Qtpnl389HY9CPZ" +
		"9JPYbHTdYDSRms1FZqKwrkiiCOppUllZTM2YrPflwGMMNcJf9OmqoigLO#dHbivBo5RZgJQ" +
		"KcvgQC0EvgF1QCptbKkWzexXTcj1JvYcNV9IW65LOmLMn4Hkm6civPnDpv6dokSuA#VIBEM" +
		"u2$tkfxgqmR$V$FGeXUkAPnl7$sphAQilvHcgvRoBQ0pwLJAwNnFZ9gqtkgTBvgmCyGTKuk" +
		"XftHfJLk3hPIAMzQLnNxcZ$o4gkXsokWz7StMCJl8h$r#7UIEMwTQmuOQzNSUt6TPXxBKjd" +
		"iKVOyS99gqnUVNfWBiLS$NfaGBP#bM5g2d7#9BwnU2lBKoxftZEAMvNGKsdvGgnWA2DcyEV" +
		"MMAMLuXXWwsxeQo$fCleGEKAEanFaDFbDZhh#Vy7h2waZFuW0og4zHVxq#LKJIQSuQzfk3J" +
		"jecqcC36Uxn$WQI8w9ku#wnUW3v30vHgwH47s50#jGxQIOv9fscQzEvb4LlZaHNxkQjtpQ6" +
		"X8bKqajcKccaJcadimbZIRkREesqcfYT91Ee#TRiHSPsntm37F85gFt6DiUzul84veQ$xmW" +
		"U6stvdtigmzVBRzxTLhjdPOEavMcpZohVvSlHucnlqoUPm5r55XwMu2$qTVk6jXMolIVDFQ" +
		"CiPUCDMi6lRuu#orzq9$Nn2utDkgRkxNFo0DzVmzpoHzv93$bXtoNR$9Lli2wvALyDkhLWF" +
		"uN#lvStv$9BTxlanlacboIYt91NbDpbyaRUIStvJhLLJalvsYlo6LvIzj3xf6xf9VS8RVbh" +
		"CdmHD#Vab$ocFSFv9Dyb8TmT#HaxlSeJuGydZwbt365R0THn35L#dHNn86x1oBKDHg7W2TJ" +
		"2W7F$ZIU$Wv9vHV0uNSWXLybHKByzYWIuZdi15AcJtkblmzzA9v$ZeNYtkkdWEJgCqkXxYy" +
		"oD32B");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = func_list.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
				}
			},
			new Action() {	// [1] paramFunc = INT iddecl.id LPAR param_list.p RPAR LBRACKET stmt_list.t RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_t = _symbols[offset + 7];
					final List t = (List) _symbol_t.value;
					 return new ParamFunc(id,p,t);
				}
			},
			new Action() {	// [2] funccall = idUse.id LPAR arg_list.l RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					return new FuncCall(id,l);
				}
			},
			new Action() {	// [3] funcStmt = funccall.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final FuncCall a = (FuncCall) _symbol_a.value;
					return new FuncStmt(a);
				}
			},
			Action.RETURN,	// [4] stmt = ifStmt
			Action.RETURN,	// [5] stmt = whileStmt
			Action.RETURN,	// [6] stmt = declare
			Action.RETURN,	// [7] stmt = assign
			Action.RETURN,	// [8] stmt = returnStmt
			Action.RETURN,	// [9] stmt = funcStmt
			new Action() {	// [10] ifStmt = IF LPAR expr.a RPAR LBRACKET stmt_list.t RBRACKET else.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final List t = (List) _symbol_t.value;
					final Symbol _symbol_e = _symbols[offset + 8];
					final ElseStmt e = (ElseStmt) _symbol_e.value;
					return new IfStmt(a,t, new Opt(e));
				}
			},
			new Action() {	// [11] param = INT iddecl.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					return new Param(id);
				}
			},
			new Action() {	// [12] param_list = param.par
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_par = _symbols[offset + 1];
					final Param par = (Param) _symbol_par.value;
					 return new List().add(par);
				}
			},
			new Action() {	// [13] param_list = param_list.a COMMA param.par
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_par = _symbols[offset + 3];
					final Param par = (Param) _symbol_par.value;
					 return a.add(par);
				}
			},
			new Action() {	// [14] param_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			Action.RETURN,	// [15] arg = expr
			new Action() {	// [16] arg_list = arg.ar
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ar = _symbols[offset + 1];
					final Expr ar = (Expr) _symbol_ar.value;
					 return new List().add(ar);
				}
			},
			new Action() {	// [17] arg_list = arg_list.a COMMA arg.ar
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_ar = _symbols[offset + 3];
					final Expr ar = (Expr) _symbol_ar.value;
					 return a.add(ar);
				}
			},
			new Action() {	// [18] arg_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			new Action() {	// [19] else = ELSE LBRACKET stmt_list.u RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_u = _symbols[offset + 3];
					final List u = (List) _symbol_u.value;
					return new ElseStmt(u);
				}
			},
			Action.NONE,  	// [20] else = 
			new Action() {	// [21] whileStmt = WHILE LPAR expr.a RPAR LBRACKET stmt_list.t RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final List t = (List) _symbol_t.value;
					return new WhileStmt(a,t);
				}
			},
			new Action() {	// [22] declare = INT iddecl.id SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					 return new Declare(id, new Opt());
				}
			},
			new Action() {	// [23] declare = INT iddecl.id ASSIGN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final Expr a = (Expr) _symbol_a.value;
					 return new Declare(id,new Opt(a));
				}
			},
			new Action() {	// [24] returnStmt = RETURN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new ReturnStmt(a);
				}
			},
			new Action() {	// [25] assign = idUse.id ASSIGN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					return new Assignment(id,a);
				}
			},
			new Action() {	// [26] stmt_list = stmt.st
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_st = _symbols[offset + 1];
					final Stmt st = (Stmt) _symbol_st.value;
					 return new List().add(st);
				}
			},
			new Action() {	// [27] stmt_list = stmt_list.a stmt.st
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_st = _symbols[offset + 2];
					final Stmt st = (Stmt) _symbol_st.value;
					 return a.add(st);
				}
			},
			new Action() {	// [28] func_list = paramFunc.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 1];
					final ParamFunc func = (ParamFunc) _symbol_func.value;
					 return new List().add(func);
				}
			},
			new Action() {	// [29] func_list = func_list.a paramFunc.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_func = _symbols[offset + 2];
					final ParamFunc func = (ParamFunc) _symbol_func.value;
					 return a.add(func);
				}
			},
			new Action() {	// [30] compare = sum.a EQ sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Eq(a,b);
				}
			},
			new Action() {	// [31] compare = sum.a NEQ sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Neq(a,b);
				}
			},
			new Action() {	// [32] compare = sum.a GTHN sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Gthn(a,b);
				}
			},
			new Action() {	// [33] compare = sum.a LTHN sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Lthn(a,b);
				}
			},
			new Action() {	// [34] compare = sum.a GEQ sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Geq(a,b);
				}
			},
			new Action() {	// [35] compare = sum.a LEQ sum.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					return new Leq(a,b);
				}
			},
			Action.RETURN,	// [36] expr = sum
			Action.RETURN,	// [37] expr = compare
			new Action() {	// [38] sum = sum.a ADD term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Add(a, b);
				}
			},
			new Action() {	// [39] sum = sum.a SUB term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a, b);
				}
			},
			Action.RETURN,	// [40] sum = term
			new Action() {	// [41] term = term.a MUL factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a, b);
				}
			},
			new Action() {	// [42] term = term.a DIV factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a, b);
				}
			},
			new Action() {	// [43] term = term.a MOD factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a, b);
				}
			},
			Action.RETURN,	// [44] term = factor
			Action.RETURN,	// [45] factor = numeral
			Action.RETURN,	// [46] factor = funccall
			Action.RETURN,	// [47] factor = idUse
			new Action() {	// [48] numeral = NUMERAL.num
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol num = _symbols[offset + 1];
					return new Numeral(num);
				}
			},
			new Action() {	// [49] idUse = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					return new IdUse(id);
				}
			},
			new Action() {	// [50] iddecl = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					return new IdDecl(id);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
