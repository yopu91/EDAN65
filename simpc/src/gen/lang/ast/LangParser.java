package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short NUMERAL = 2;
		static public final short INT = 3;
		static public final short IF = 4;
		static public final short WHILE = 5;
		static public final short RETURN = 6;
		static public final short SEMI = 7;
		static public final short EQ = 8;
		static public final short NEQ = 9;
		static public final short GTHN = 10;
		static public final short LTHN = 11;
		static public final short GEQ = 12;
		static public final short LEQ = 13;
		static public final short ADD = 14;
		static public final short SUB = 15;
		static public final short LPAR = 16;
		static public final short RPAR = 17;
		static public final short LBRACKET = 18;
		static public final short RBRACKET = 19;
		static public final short MUL = 20;
		static public final short DIV = 21;
		static public final short MOD = 22;
		static public final short ASSIGN = 23;
		static public final short COMMA = 24;
		static public final short ELSE = 25;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"NUMERAL",
			"INT",
			"IF",
			"WHILE",
			"RETURN",
			"SEMI",
			"EQ",
			"NEQ",
			"GTHN",
			"LTHN",
			"GEQ",
			"LEQ",
			"ADD",
			"SUB",
			"LPAR",
			"RPAR",
			"LBRACKET",
			"RBRACKET",
			"MUL",
			"DIV",
			"MOD",
			"ASSIGN",
			"COMMA",
			"ELSE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9ojLKTJ544K$WPGC8EhWY0Y8B0Wh086437dB6BEeIpBL5PfUV6Y9wto5tZpecML1qyU$0S" +
		"Un9nppZaWnkStFM#7NdOMjShP#lfztUzxhzzqz$G2pYuiG1r2c8hfc8dbw8uUI4S6UY8PAU" +
		"YIq5kFaUYRqDi9LUYltWvOWOLniKMef7S8PcCmvbby2aQWmIY6OhvcQ4GrXg6RbQ42DHYDi" +
		"HYFYPYCEUY8JDMwaQanMczy5KhHkTqSPIYqSlIEqPR7gOEhd#jNduNXM1mNjUmlyyn37pI8" +
		"e1zok7u5p6dxwf6B4lJ202p18Fh#DkSYhIqVQx3Ky3G$Jpq6MhpHvrrDX8TiIv5dyR3FYzc" +
		"hydlUt17ExR5QdutnsJYVJV3P99zDyzaCdyqYMykpoPha1vBaj5LXC5PY5FU$4Qlv1ZbSqr" +
		"xStJwiC9yhMyZtBZBx6qxeTP3KZZU3PoJgJUQ#PoQCpUKtaHV3YxbMhYA3##YDEtp3h9WCQ" +
		"VoQElDBxAedifJgg3Q9SzlQQ1MfFBFjvSXi9qTgdFfFrVTazV5H$vO7l4q6itANspv7Rw8E" +
		"$CPTtx$MbixlskCHFu#Tq#4loaCcmaF8KjYyD4QTxlTQv$xVp3sRRasfFFzLLeN1AACksTG" +
		"9hDi3yrGGJIxN$bnY2R7Th3frn3NYHrIJ27ns4zb40t4GS1Zl996VKFyfzlE8DEq$9sg8dS" +
		"G7ZXSJ8S$dT6ApLNNJY0FADyJEwMInsK$KaI#YFQgwwqIpfTjiyHvgCzGkKxjQxLeHUKkxN" +
		"liRr6wqScoYvXT9jpPha4FV5jeZgjl6vhWLjrtj3ZjEnoBCUS$ALQlsN7IC$YSqGzl61e7F" +
		"OIlkCyrquf3bJo4MMlrZ5WyHMvItMECdhNf30NCMM7olfSqAhj79LLkWjaHjkUO8QxzIxN2" +
		"rTTOy#u9og##inI#tcNkAsfbjOjPvHkwR7OQyWpxoKnxAD$agBV95cisQ#e#ya4$ANiQCFp" +
		"VjCzC#9Ux91Jalv#IL#b#xPqtkobcst#KCspl4RU8MSPEuGLmXBXENv2BRwt9DhieRQT8SZ" +
		"qtxH1wnVKzyb0$oW4FLvbOe9ofuE#Pmn$ln7XZ0VX3ogIcZFw8tOeGP1fb$7HV917WFfn3S" +
		"PzubXHmhv0rNH3kGus7gmeolfAsaBU5u48fzE0PvvArmUBEreZ#HRUui1zM$0JjyG54=");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = func_list.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
				}
			},
			Action.RETURN,	// [1] function = paramFunc
			new Action() {	// [2] paramFunc = INT iddecl.id LPAR param_list.p RPAR LBRACKET stmt_list.t RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_t = _symbols[offset + 7];
					final List t = (List) _symbol_t.value;
					 return new ParamFunc(id,p,t);
				}
			},
			new Action() {	// [3] funccall = idUse.id LPAR arg_list.l RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					return new FuncCall(id,l);
				}
			},
			new Action() {	// [4] funcStmt = funccall.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final FuncCall a = (FuncCall) _symbol_a.value;
					return new FuncStmt(a);
				}
			},
			Action.RETURN,	// [5] stmt = ifStmt
			Action.RETURN,	// [6] stmt = whileStmt
			Action.RETURN,	// [7] stmt = declare
			Action.RETURN,	// [8] stmt = assign
			Action.RETURN,	// [9] stmt = returnStmt
			Action.RETURN,	// [10] stmt = funcStmt
			new Action() {	// [11] ifStmt = IF LPAR expr.a RPAR LBRACKET stmt_list.t RBRACKET else
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final List t = (List) _symbol_t.value;
					return new IfStmt(a,t);
				}
			},
			new Action() {	// [12] param = INT iddecl.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					return new Param(id);
				}
			},
			new Action() {	// [13] param_list = param.par
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_par = _symbols[offset + 1];
					final Param par = (Param) _symbol_par.value;
					 return new List().add(par);
				}
			},
			new Action() {	// [14] param_list = param_list.a COMMA param.par
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_par = _symbols[offset + 3];
					final Param par = (Param) _symbol_par.value;
					 return a.add(par);
				}
			},
			new Action() {	// [15] param_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			Action.RETURN,	// [16] arg = expr
			new Action() {	// [17] arg_list = arg.ar
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ar = _symbols[offset + 1];
					final Expr ar = (Expr) _symbol_ar.value;
					 return new List().add(ar);
				}
			},
			new Action() {	// [18] arg_list = arg_list.a COMMA arg.ar
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_ar = _symbols[offset + 3];
					final Expr ar = (Expr) _symbol_ar.value;
					 return a.add(ar);
				}
			},
			new Action() {	// [19] arg_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			new Action() {	// [20] else = ELSE LBRACKET stmt_list.u RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_u = _symbols[offset + 3];
					final List u = (List) _symbol_u.value;
					return new ElseStmt(u);
				}
			},
			Action.NONE,  	// [21] else = 
			new Action() {	// [22] whileStmt = WHILE LPAR expr.a RPAR LBRACKET stmt_list.t RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 6];
					final List t = (List) _symbol_t.value;
					return new WhileStmt(a,t);
				}
			},
			new Action() {	// [23] declare = INT iddecl.id SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					 return new Declare(id, new Opt());
				}
			},
			new Action() {	// [24] declare = INT iddecl.id ASSIGN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final Expr a = (Expr) _symbol_a.value;
					 return new Declare(id,new Opt(a));
				}
			},
			new Action() {	// [25] returnStmt = RETURN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new ReturnStmt(a);
				}
			},
			new Action() {	// [26] assign = idUse.id ASSIGN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					return new Assignment(id,a);
				}
			},
			new Action() {	// [27] stmt_list = stmt.st
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_st = _symbols[offset + 1];
					final Stmt st = (Stmt) _symbol_st.value;
					 return new List().add(st);
				}
			},
			new Action() {	// [28] stmt_list = stmt_list.a stmt.st
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_st = _symbols[offset + 2];
					final Stmt st = (Stmt) _symbol_st.value;
					 return a.add(st);
				}
			},
			new Action() {	// [29] func_list = function.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_func = _symbols[offset + 1];
					final Function func = (Function) _symbol_func.value;
					 return new List().add(func);
				}
			},
			new Action() {	// [30] func_list = func_list.a function.func
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_func = _symbols[offset + 2];
					final Function func = (Function) _symbol_func.value;
					 return a.add(func);
				}
			},
			new Action() {	// [31] compare = expr.a EQ factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Eq(a,b);
				}
			},
			new Action() {	// [32] compare = expr.a NEQ factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Neq(a,b);
				}
			},
			new Action() {	// [33] compare = expr.a GTHN factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Gthn(a,b);
				}
			},
			new Action() {	// [34] compare = expr.a LTHN factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Lthn(a,b);
				}
			},
			new Action() {	// [35] compare = expr.a GEQ factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Geq(a,b);
				}
			},
			new Action() {	// [36] compare = expr.a LEQ factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					return new Leq(a,b);
				}
			},
			new Action() {	// [37] expr = expr.a ADD term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Add(a, b);
				}
			},
			new Action() {	// [38] expr = expr.a SUB term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a, b);
				}
			},
			Action.RETURN,	// [39] expr = term
			Action.RETURN,	// [40] expr = compare
			new Action() {	// [41] term = term.a MUL factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a, b);
				}
			},
			new Action() {	// [42] term = term.a DIV factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a, b);
				}
			},
			new Action() {	// [43] term = term.a MOD factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a, b);
				}
			},
			Action.RETURN,	// [44] term = factor
			Action.RETURN,	// [45] factor = numeral
			Action.RETURN,	// [46] factor = funcStmt
			Action.RETURN,	// [47] factor = idUse
			new Action() {	// [48] numeral = NUMERAL.num
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol num = _symbols[offset + 1];
					return new Numeral(num);
				}
			},
			new Action() {	// [49] idUse = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					return new IdUse(id);
				}
			},
			new Action() {	// [50] iddecl = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					return new IdDecl(id);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
