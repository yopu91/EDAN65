/*FINITO*/

Program ::= ParamFunc*;
ParamFunc	 	::= Name:IdDecl Params:Param* Stmts:Stmt*;
Param			::= IdDecl;

abstract Stmt;

WhileStmt:Stmt		::= Cond:Expr Stmt*;
IfStmt:Stmt		::= Cond:Expr Then:Stmt* [ElseStmt];
ElseStmt:Stmt		::= Stmt*; 
ReturnStmt:Stmt		::= Expr;
FuncCall:Expr		::= Name:IdUse E:Expr*;

FuncStmt:Stmt 		::= FuncCall; 

Assignment:Stmt		::= Identifier:IdUse Expression:Expr;
Declare:Stmt		::= Identifier:IdDecl [Expr];


abstract Expr;
Numeral:Expr		::= <NUMERAL>;
IdUse:Expr		::= <ID>; //anv√§nd
IdDecl			::= <ID>; //deklarera

BinaryExpr:Expr		::= Left:Expr Right:Expr;

Add:BinaryExpr;	//	::= Left:DivMult Right:PlusMinus;
Sub:BinaryExpr;	//  	::= Left:DivMult Right:PlusMinus;
Div:BinaryExpr;	//  	::= Left:Term Right:DivMult;
Mul:BinaryExpr;	//  	::= Left:Term Right:DivMult;
Mod:BinaryExpr;	//  	::= Left:Term Right:DivMult;

Neq:BinaryExpr;	// 	::= Left:Term Right:Term;
Eq:BinaryExpr;	// 	::= Left:Term Right:Term;
Leq:BinaryExpr;	// 	::= Left:Term Right:Term;
Lthn:BinaryExpr;// 	::= Left:Term Right:Term;
Geq:BinaryExpr;	//  	::= Left:Term Right:Term;
Gthn:BinaryExpr;// 	::= Left:Term Right:Term;
